<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="@configuration用于标记一个类为配置类，表明该类将包含一个或多个 @Bean 方法，用于定义 Spring 容器中管理的 bean。 @Configuration 表示该类是 Spring 配置的一部分，通常代替传统的 XML 配置文件。使用该注解的类会被 Spring 容器处理，并允许在该类中定义和管理多个 bean。 主要作用： 标记配置类：@Configuration 用于标识一">
<meta property="og:type" content="article">
<meta property="og:title" content="springboot中常见注解">
<meta property="og:url" content="http://example.com/2025/01/10/%E6%B3%A8%E8%A7%A3/index.html">
<meta property="og:site_name" content="tyc的小窝">
<meta property="og:description" content="@configuration用于标记一个类为配置类，表明该类将包含一个或多个 @Bean 方法，用于定义 Spring 容器中管理的 bean。 @Configuration 表示该类是 Spring 配置的一部分，通常代替传统的 XML 配置文件。使用该注解的类会被 Spring 容器处理，并允许在该类中定义和管理多个 bean。 主要作用： 标记配置类：@Configuration 用于标识一">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2025-01-10T15:37:09.686Z">
<meta property="article:modified_time" content="2025-01-17T11:52:08.385Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2025/01/10/%E6%B3%A8%E8%A7%A3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>springboot中常见注解 | tyc的小窝</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">tyc的小窝</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/01/10/%E6%B3%A8%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="tyc的小窝">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          springboot中常见注解
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-01-10 23:37:09" itemprop="dateCreated datePublished" datetime="2025-01-10T23:37:09+08:00">2025-01-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-01-17 19:52:08" itemprop="dateModified" datetime="2025-01-17T19:52:08+08:00">2025-01-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h4 id="configuration"><a href="#configuration" class="headerlink" title="@configuration"></a>@configuration</h4><p>用于标记一个类为配置类，表明该类将包含一个或多个 <code>@Bean</code> 方法，用于定义 Spring 容器中管理的 bean。</p>
<p>@Configuration 表示该类是 Spring 配置的一部分，通常代替传统的 XML 配置文件。使用该注解的类会被 Spring 容器处理，并允许在该类中定义和管理多个 bean。</p>
<h5 id="主要作用："><a href="#主要作用：" class="headerlink" title="主要作用："></a>主要作用：</h5><ol>
<li><strong>标记配置类</strong>：<code>@Configuration</code> 用于标识一个类是配置类，这个类中的方法通常会使用 <code>@Bean</code> 注解来定义 Spring 容器中需要管理的 bean。</li>
<li><strong>替代 XML 配置</strong>：它允许你通过 Java 代码配置 Spring 应用上下文，避免了传统 XML 配置的繁琐。</li>
<li><strong>增强功能</strong>：<code>@Configuration</code> 类默认会被 CGLIB 动态代理增强，使得在配置类中定义的 bean 能够进行更强的管理，例如支持方法级的 bean 定义。</li>
</ol>
<p><code>@RequestBody</code> 是 Spring Framework 中的一种注解，通常用于处理 HTTP 请求的正文（body）数据。它的主要作用是将请求中的数据自动绑定到 Java 对象上。</p>
<h4 id="RequestBody"><a href="#RequestBody" class="headerlink" title="@RequestBody"></a>@RequestBody</h4><h5 id="用法："><a href="#用法：" class="headerlink" title="用法："></a>用法：</h5><p><code>@RequestBody</code> 注解用于方法参数上，表示从 HTTP 请求的 Body 部分提取数据并将其转换为 Java 对象。Spring 会根据请求的 <code>Content-Type</code> 和方法参数的类型，自动将请求内容转换为相应的对象。</p>
<h5 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h5><p>假设我们有一个 <code>User</code> 类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">javaCopy Codepublic <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Getters and Setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在控制器方法中使用 <code>@RequestBody</code> 注解来处理传递的 JSON 数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">javaCopy Code@RestController</span><br><span class="line">public class UserController &#123;</span><br><span class="line"></span><br><span class="line">    @PostMapping(&quot;/user&quot;)</span><br><span class="line">    public String createUser(@RequestBody User user) &#123;</span><br><span class="line">        return &quot;User received: &quot; + user.getName() + &quot;, Age: &quot; + user.getAge();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="解释："><a href="#解释：" class="headerlink" title="解释："></a>解释：</h5><ul>
<li><p>当客户端发送一个 HTTP POST 请求到 <code>/user</code> 路径，且请求的 Body 中包含 JSON 数据时，Spring 会自动将该 JSON 数据转换为 <code>User</code> 对象。</p>
</li>
<li><p>例如，客户端发送的请求体如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jsonCopy Code&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="string">&quot;age&quot;</span>: <span class="number">30</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Spring 会将该 JSON 数据转换为User对象，调用createUser方法时，user</p>
<p> 参数将包含name和age的值。</p>
</li>
</ul>
<h5 id="常见用途："><a href="#常见用途：" class="headerlink" title="常见用途："></a>常见用途：</h5><ol>
<li><strong>JSON 数据处理</strong>：<code>@RequestBody</code> 是处理 JSON 请求的主要方式，Spring 会使用 <code>HttpMessageConverter</code>（如 Jackson）来自动将 JSON 数据转换为 Java 对象。</li>
<li><strong>处理复杂请求</strong>：对于包含复杂嵌套结构的请求体（例如嵌套对象、数组等），<code>@RequestBody</code> 可以非常方便地将数据映射为相应的 Java 类。</li>
</ol>
<h5 id="需要注意的事项："><a href="#需要注意的事项：" class="headerlink" title="需要注意的事项："></a>需要注意的事项：</h5><ul>
<li>由于使用 <code>@RequestBody</code> 会自动解析请求体，因此它只能用于 <code>POST</code>、<code>PUT</code>、<code>PATCH</code> 等请求类型。</li>
<li>在使用 <code>@RequestBody</code> 时，通常需要客户端设置正确的 <code>Content-Type</code>，如 <code>application/json</code>。</li>
</ul>
<h3 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h3><p><code>@Autowired</code> 是 Spring Framework 中的一种注解，主要用于实现依赖注入（Dependency Injection）。它可以让 Spring 自动为你的类的字段、构造方法或 setter 方法注入所需的依赖对象。</p>
<h4 id="用法和作用："><a href="#用法和作用：" class="headerlink" title="用法和作用："></a>用法和作用：</h4><ol>
<li><strong>自动注入依赖</strong>：<code>@Autowired</code> 注解使得 Spring 可以自动将符合要求的 Bean 注入到你的类中，而无需手动配置。Spring 会根据类型、名称或者构造函数来寻找匹配的 Bean 并进行注入。</li>
</ol>
<h4 id="主要的使用方式："><a href="#主要的使用方式：" class="headerlink" title="主要的使用方式："></a>主要的使用方式：</h4><h5 id="1-字段注入"><a href="#1-字段注入" class="headerlink" title="1. 字段注入"></a>1. <strong>字段注入</strong></h5><p>通过 <code>@Autowired</code> 注解在类的成员变量上，Spring 会自动为这个字段赋值。最常见的使用方式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">javaCopy Code@Component</span><br><span class="line">public class Car &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private Engine engine; // 自动注入 Engine 类型的 Bean</span><br><span class="line"></span><br><span class="line">    public void start() &#123;</span><br><span class="line">        engine.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，<code>Car</code> 类依赖 <code>Engine</code> 类，通过 <code>@Autowired</code> 注解，Spring 会自动注入一个 <code>Engine</code> 类型的 Bean 到 <code>Car</code> 的 <code>engine</code> 字段。</p>
<h5 id="2-构造方法注入"><a href="#2-构造方法注入" class="headerlink" title="2. 构造方法注入"></a>2. <strong>构造方法注入</strong></h5><p><code>@Autowired</code> 也可以应用到构造方法上，Spring 会根据构造方法的参数类型来自动注入依赖的 Bean。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">javaCopy Code@Component</span><br><span class="line">public class Car &#123;</span><br><span class="line">    private final Engine engine;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public Car(Engine engine) &#123; // 自动注入 Engine 类型的 Bean</span><br><span class="line">        this.engine = engine;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void start() &#123;</span><br><span class="line">        engine.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式是推荐的做法，特别是当依赖项为必需时，可以更好地控制依赖关系。</p>
<h5 id="3-Setter-方法注入"><a href="#3-Setter-方法注入" class="headerlink" title="3. Setter 方法注入"></a>3. <strong>Setter 方法注入</strong></h5><p>你也可以将 <code>@Autowired</code> 放在 setter 方法上，Spring 会在创建对象后通过调用 setter 方法注入依赖。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">javaCopy Code@Component</span><br><span class="line">public class Car &#123;</span><br><span class="line">    private Engine engine;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public void setEngine(Engine engine) &#123; // 自动注入 Engine 类型的 Bean</span><br><span class="line">        this.engine = engine;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void start() &#123;</span><br><span class="line">        engine.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这也是一种常见的依赖注入方式。</p>
<h4 id="自动注入的原理："><a href="#自动注入的原理：" class="headerlink" title="自动注入的原理："></a>自动注入的原理：</h4><ul>
<li>Spring 会根据 <code>@Autowired</code> 注解标记的字段、构造函数或 setter 方法，查找匹配的 Bean 实例并注入。默认情况下，它是根据 <strong>类型</strong> 来进行匹配。</li>
<li>如果找到多个匹配的 Bean，且没有明确的标识，Spring 会抛出异常。在这种情况下，你可以使用 <code>@Qualifier</code> 来指定具体的 Bean。</li>
</ul>
<h4 id="例外和配置："><a href="#例外和配置：" class="headerlink" title="例外和配置："></a>例外和配置：</h4><ul>
<li><p><strong>如果没有找到匹配的 Bean</strong>：如果没有符合要求的 Bean，Spring 会抛出异常，默认情况下是 <code>NoSuchBeanDefinitionException</code>。如果你希望在没有匹配 Bean 时不报错，可以使用 <code>@Autowired(required = false)</code> 来设置为非必需的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javaCopy Code@Autowired(required = false)</span><br><span class="line">private Engine engine; // 如果没有 Engine 类型的 Bean，Spring 不会抛出异常</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>多重 Bean 注入冲突</strong>：如果 Spring 容器中存在多个同类型的 Bean，Spring 默认会抛出 <code>NoUniqueBeanDefinitionException</code>。这时可以通过 <code>@Qualifier</code> 来明确指定要注入哪个 Bean：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">javaCopy Code@Autowired</span><br><span class="line">@Qualifier(&quot;carEngine&quot;) // 明确指定注入哪个 Bean</span><br><span class="line">private Engine engine;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><ul>
<li><code>@Autowired</code> 是 Spring 中用于实现自动依赖注入的注解。它可以用于字段、构造函数或 setter 方法上。</li>
<li>Spring 会根据 Bean 类型自动查找并注入依赖项。</li>
<li>使用 <code>@Autowired</code> 可以大大减少手动配置和管理 Bean 之间的依赖关系，提高代码的可维护性和可扩展性。</li>
</ul>
<h2 id="1-组件相关注解"><a href="#1-组件相关注解" class="headerlink" title="1. 组件相关注解"></a><strong>1. 组件相关注解</strong></h2><ul>
<li><strong>@Controller</strong>：用于修饰 MVC 中控制器层的组件。Spring Boot 中的组件扫描功能会识别此注解，并为被修饰的类实例化一个对象。它通常与@RequestMapping 一起使用。当 Spring MVC 收到请求时，会将其转发到指定路径的方法进行处理。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user/admin&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserAdminController</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>@Service</strong>：通常用于修饰服务层的组件。声明一个对象时，会实例化该类对象并将其注入到 bean 容器中。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>@Repository</strong>：用于修饰数据访问对象（DAO）层的组件。DAO 层的组件专注于系统数据的处理，例如数据库中的数据。它们也会被组件扫描并生成实例化对象。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RoleRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;Role, Long&gt; &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>@Component</strong>：一般指代组件。当组件难以分类时，可以使用此注解进行标记。其功能与@Service 类似。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoHandler</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-与-Bean-实例和生命周期相关的注解"><a href="#2-与-Bean-实例和生命周期相关的注解" class="headerlink" title="2. 与 Bean 实例和生命周期相关的注解"></a><strong>2. 与 Bean 实例和生命周期相关的注解</strong></h2><ul>
<li><strong>@Bean</strong>：用于修饰方法，表示该方法将创建一个 Bean 实例，并由 Spring 容器进行管理。示例代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="comment">// 相当于在 XML 中配置一个 Bean</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Uploader <span class="title function_">initFileUploader</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FileUploader</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>@Scope</strong>：用于声明 Spring Bean 实例的作用域。作用域如下：<ul>
<li>singleton：单例模式。在 Spring 容器中实例是唯一的，这是 Spring 的默认实例作用域类型。</li>
<li>prototype：原型模式。每次使用时都会重新创建实例。</li>
<li>request：在同一请求中使用相同的实例，不同请求创建新的实例。</li>
<li>session：在同一会话中使用相同的实例，不同会话创建新的实例。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RestTemplateConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Scope(&quot;singleton&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>@Primary</strong>：当存在同一对象的多个实例时，优先选择此实例。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaConfig</span> &#123;</span><br><span class="line">    <span class="comment">// 首选</span></span><br><span class="line">    <span class="meta">@Bean(&quot;b1&quot;)</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    B <span class="title function_">b1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;b2&quot;)</span></span><br><span class="line">    B <span class="title function_">b2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>@PostConstruct</strong>：用于修饰方法，在对象实例创建和依赖注入完成后执行，可用于初始化对象实例。</li>
<li><strong>@PreDestroy</strong>：用于修饰方法，在对象实例即将被 Spring 容器移除时执行，可用于释放对象实例持有的资源。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Demo</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;构造方法...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;init...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postConstruct</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;postConstruct...&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PreDestroy</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preDestroy</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;preDestroy...&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;destroy...&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">构造方法...</span><br><span class="line">postConstruct...</span><br><span class="line">init...</span><br><span class="line">preDestroy...</span><br><span class="line">destroy...</span><br></pre></td></tr></table></figure>

<h2 id="3-依赖注入注解"><a href="#3-依赖注入注解" class="headerlink" title="3. 依赖注入注解"></a><strong>3. 依赖注入注解</strong></h2><ul>
<li><strong>@Autowired</strong>：根据对象的类型自动注入依赖对象。默认情况下，它要求注入的对象实例必须存在。可以配置 required &#x3D; false 来注入可能不存在的对象。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired(required = false)</span></span><br><span class="line">    <span class="keyword">private</span> UserConfig userConfig;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>@Resource</strong>：默认情况下，根据对象的名称自动注入依赖对象。如果要根据类型注入，可以设置属性 type &#x3D; UmsAdminService.class。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@Resource(name = &quot;userServiceImpl&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>@Qualifier</strong>：当存在同一类型的多个 bean 时，使用@Autowired 导入会导致错误，表示当前对象不唯一，Spring 不知道要导入哪个依赖。此时，我们可以使用@Qualifier 进行更细粒度的控制并选择其中一个实例。它通常与@Autowired 一起使用。示例如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier(&quot;deptService&quot;)</span></span><br><span class="line"><span class="keyword">private</span> DeptService deptService;</span><br></pre></td></tr></table></figure>

<h2 id="4-SpringMVC-相关注解"><a href="#4-SpringMVC-相关注解" class="headerlink" title="4. SpringMVC 相关注解"></a><strong>4. SpringMVC 相关注解</strong></h2><ul>
<li><strong>@RequestMapping</strong>：提供路由信息，负责将 URL 映射到 Controller 中的指定函数。当用于方法上时，可以指定请求协议，如 GET、POST、PUT、DELETE 等。</li>
<li><strong>@RequestBody</strong>：表示请求体的 Content - Type 必须是 application&#x2F;json 格式的数据。接收到数据后，会自动将数据绑定到 Java 对象。</li>
<li><strong>@ResponseBody</strong>：表示此方法的返回结果直接写入 HTTP 响应体。返回数据的格式为 application&#x2F;json。 例如，如果请求参数是 json 格式，返回参数也是 json 格式，示例代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;api&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;login&quot;, method = RequestMethod.POST)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity <span class="title function_">login</span><span class="params">(<span class="meta">@RequestBody</span> UserLoginDTO request)</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResponseEntity</span>(HttpStatus.OK);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>@RestController</strong>：与@Controller 类似，用于注释控制器层组件。不同之处在于它是@ResponseBody 和@Controller 的组合。 即，当在类上使用@RestController 时，表示当前类中所有对外暴露的接口方法，返回数据的格式都是 application&#x2F;json。示例代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/login&quot;, method = RequestMethod.POST)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity <span class="title function_">login</span><span class="params">(<span class="meta">@RequestBody</span> UserLoginDTO request)</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResponseEntity</span>(HttpStatus.OK);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>@RequestParam</strong>：用于接收请求参数为表单类型的数据。通常用于方法的参数前面。示例代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;login&quot;, method = RequestMethod.POST)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity <span class="title function_">login</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestParam(value = &quot;userName&quot;, required = true)</span> String userName,</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestParam(value = &quot;userPwd&quot;, required = true)</span> String userPwd)</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResponseEntity</span>(HttpStatus.OK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>@PathVariable</strong>：用于获取请求路径中的参数。通常用于 restful 风格的 API。示例代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;queryProduct/&#123;id&#125;&quot;, method = RequestMethod.POST)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity <span class="title function_">queryProduct</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> String id)</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResponseEntity</span>(HttpStatus.OK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>@GetMapping、@PostMapping、@PutMapping、@DeleteMapping</strong>：除了@RequestMapping 能够指定请求方法外，还有一些其他注解可以用于注释接口路径请求。例如，当@GetMapping 用于方法上时，表示仅支持 get 请求方法。它等同于@RequestMapping(value &#x3D; “&#x2F;get”, method &#x3D; RequestMethod.GET)。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;get&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResponseEntity</span>(HttpStatus.OK);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PostMapping(&quot;post&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity <span class="title function_">post</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResponseEntity</span>(HttpStatus.OK);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PutMapping(&quot;put&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity <span class="title function_">put</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResponseEntity</span>(HttpStatus.OK);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@DeleteMapping(&quot;delete&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity <span class="title function_">delete</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResponseEntity</span>(HttpStatus.OK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-配置相关注解"><a href="#5-配置相关注解" class="headerlink" title="5. 配置相关注解"></a><strong>5. 配置相关注解</strong></h2><ul>
<li><strong>@Configuration</strong>：表示声明一个基于 Java 的配置类。Spring Boot 提倡基于 Java 对象的配置，相当于以前在 xml 中配置 bean。例如，声明一个配置类 AppConfig，然后初始化一个 Uploader 对象。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Uploader <span class="title function_">initOSSUploader</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OSSUploader</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>@EnableAutoConfiguration</strong>：@EnableAutoConfiguration 可以帮助 Spring Boot 应用程序将所有符合条件的@Configuration 配置类加载到当前的 Spring Boot 中，创建与配置类对应的 Beans，并将 Bean 实体交给 IoC 容器管理。在某些场景下，如果我们想要避免某些配置类的扫描（包括避免一些第三方 jar 下的配置），可以这样处理。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration(exclude = &#123;</span></span><br><span class="line"><span class="meta">        org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration.class</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>@ComponentScan</strong>：注释哪些路径下的类需要被 Spring 扫描。用于自动发现和组装一些 Bean 对象。默认配置是扫描当前文件夹及子目录中的所有类。如果我们想要指定扫描某些包路径，可以这样处理。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ComponentScan(basePackages = &#123;&quot;com.xxx.a&quot;, &quot;com.xxx.b&quot;, &quot;com.xxx.c&quot;&#125;)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>@SpringBootApplication</strong>：相当于使用了@Configuration、@EnableAutoConfiguration 和@ComponentScan 这三个注解。通常用于全局启动类。示例如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PropertyApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(PropertyApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用这三个注解@configuration、@EnableAutoConfiguration 和@ComponentScan 替换@springBootApplication 也可以成功启动，@springBootApplication 只是简化了这三个注解。</p>
<ul>
<li><strong>@EnableTransactionManagement</strong>：表示启用事务支持，相当于 xml 配置方式中的 tx:annotation - driven&#x2F;&gt;。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PropertyApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(PropertyApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>@ConfigurationProperties</strong>：用于批量注入外部配置，并以对象的形式导入具有指定前缀的配置。例如，这里我们在 application.yml 中指定前缀为 secure.ignored 的属性：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">secure:</span><br><span class="line">  ignored:</span><br><span class="line">    urls: # 安全路径白名单</span><br><span class="line">      - /swagger-ui/</span><br><span class="line">      - /swagger-resources<span class="comment">/**</span></span><br><span class="line"><span class="comment">      - / **/</span>*.htm1</span><br><span class="line">      - / **<span class="comment">/*.js</span></span><br><span class="line"><span class="comment">      - / **/</span>*.css</span><br><span class="line">      - / **<span class="comment">/*.png</span></span><br><span class="line"><span class="comment">      - /favicon.ico</span></span><br><span class="line"><span class="comment">      - /actuator/**</span></span><br></pre></td></tr></table></figure>

<p>然后，在 Java 类中定义一个 urls 属性，就可以导入配置文件中的属性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;secure.ignored&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IgnoreUrlsConfig</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; urls = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>@Conditional</strong>：从 Spring 4 开始，@Conditional 注解可以用于有条件地加载 bean 对象。目前，在 Spring Boot 源代码中，@Condition 注解已经得到了广泛的扩展，用于实现智能自动配置，以满足各种使用场景。以下是一些常用的注解：<ul>
<li>@ConditionalOnBean：当指定的 Bean 存在时，配置生效。</li>
<li>@ConditionalOnMissingBean：当指定的 Bean 不存在时，配置生效。</li>
<li>@ConditionalOnClass：当指定的类在类路径中存在时，配置生效。@ConditionalOnMissingClass：当指定的类在类路径中不存在时，配置生效。</li>
<li>@ConditionalOnExpression：当给定的 SpEL 表达式的计算结果为 true 时，配置生效。</li>
<li>@ConditionalOnProperty：当指定的配置属性具有确定的值且匹配时，配置生效。 具体应用案例如下：</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConditionalConfig</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当 Test 对象存在时，创建一个对象 A</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ConditionalOnBean(Test.class)</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> A <span class="title function_">createA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当 Test 对象不存在时，创建一个对象 B</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Conditional0nMissingBean(Test.class)</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> B <span class="title function_">createB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当 Test 类存在时，创建一个对象 C</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Conditional0nclass(Test.class)</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> C <span class="title function_">createC</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">C</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当 Test 类不存在时，创建一个对象 D</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Conditional0nMissingClass(Test.class)</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> D <span class="title function_">createD</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">D</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当 enableConfig 的配置为 true 时，创建一个对象 E</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Conditiona10nExpression(&quot;$ &#123;enableConfig:false&#125;&quot;)</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">createE</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">E</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当 filter.loginFilter 的配置为 true 时，创建一个对象 F</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Conditiona10nProperty(prefix = &quot;filter&quot;, name = &quot;loginilter&quot;, havingalue =</span></span><br><span class="line"><span class="meta">            &quot;true&quot;)</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> F <span class="title function_">createF</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">F</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>@Value</strong>：在任何 Spring 管理的 Bean 中，可以通过此注解获取从任何源配置的属性值。例如，在 application.properties 文件中，定义一个参数变量：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config.name=Dylan</span><br></pre></td></tr></table></figure>

<p>在任何 bean 实例内，可以通过@Value 注解注入参数并获取参数变量的值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;config.name&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String configName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;config&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">config</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> JSON.toJSONString(configName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>@ConfigurationProperties</strong>：在每个类中使用@Value 获取属性配置值的做法实际上并不推荐。 在一般的企业项目开发中，不会使用这种混乱的写法，而且维护也很麻烦。通常，一次读取一个 Java 配置类，然后在需要的地方直接引用这个类进行使用，这样可以多次访问且便于维护。示例如下： 首先，在 application.properties 文件中定义参数变量。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config.name=demo_1 config.value=demo_value_1</span><br></pre></td></tr></table></figure>

<p>然后，创建一个 Java 配置类并注入参数变量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;config&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//... get、set 方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，在需要的地方，通过 ioc 注入 Config 对象。</p>
<ul>
<li><strong>@PropertySource</strong>：此注解用于读取我们自定义的配置文件。例如，要导入两个配置文件 test.properties 和 bussiness.properties，用法如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@PropertySource(value = &#123;&quot;test.properties&quot;, &quot;bussiness.properties&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PropertyApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(PropertyApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>@ImportResource</strong>：用于加载 xml 配置文件。例如，要导入自定义的 aaa.xml 文件，用法如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ImportResource(locations = &quot;classpath:aaa.xml&quot;)</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PropertyApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(PropertyApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-JPA-相关注解"><a href="#6-JPA-相关注解" class="headerlink" title="6. JPA 相关注解"></a><strong>6. JPA 相关注解</strong></h2><ul>
<li><strong>@Entity 和@Table</strong>：表示这是一个实体类。这两个注解通常一起使用。但是，如果表名与实体类名相同，@Table 可以省略。</li>
<li><strong>@Id</strong>：表示此属性字段对应数据库表中的主键字段。</li>
<li><strong>@Column</strong>：表示此属性字段对应的数据库表中的列名。如果字段名与列名相同，可以省略。</li>
<li><strong>@GeneratedValue</strong>：表示主键的生成策略。有以下四个选项：<ul>
<li>AUTO：表示由程序控制，是默认选项。如果未设置，则为该选项。</li>
<li>IDENTITY：表示由数据库生成，使用数据库自动递增。Oracle 不支持此方法。</li>
<li>SEQUENCE：表示主键 ID 通过数据库序列生成。MySQL 不支持此方法。</li>
<li>TABLE：表示主键由指定数据库生成。此方法有利于数据库迁移。</li>
</ul>
</li>
<li><strong>@SequenceGenerator</strong>：用于定义生成主键的序列。需要与@GeneratedValue 一起使用才能生效。以 role 表为例，相应的注解配置如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;role&quot;)</span></span><br><span class="line"><span class="meta">@SequenceGenerator(name = &quot;id_seq&quot;, sequenceName = &quot;seq_repair&quot;, allocationSize = 1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Role</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.SEQUENCE, generator = &quot;id_seq&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(nullable = false)</span></span><br><span class="line">    <span class="keyword">private</span> String roleName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(nullable = false)</span></span><br><span class="line">    <span class="keyword">private</span> String roleType;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>@Transient</strong>：表示此属性不映射到数据库表的字段。ORM 框架将忽略此属性。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Column(nullable = false)</span></span><br><span class="line"><span class="meta">@Transient</span></span><br><span class="line"><span class="keyword">private</span> String lastTime;</span><br></pre></td></tr></table></figure>

<ul>
<li>**@Basic(fetch &#x3D; FetchType.LAZY)**：用于某些属性上，可以实现懒加载的效果。即，当使用此字段时，才会加载此属性。如果配置为 fetch &#x3D; FetchType.EAGER，则表示立即加载，这也是默认的加载方式！</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Column(nullable = false)</span></span><br><span class="line"><span class="meta">@Basic(fetch = FetchType.LAZY)</span></span><br><span class="line"><span class="keyword">private</span> String roleType;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>@JoinColumn</strong>：用于注释表示表关系的字段。通常与@OneToOne 和@OneToMany 一起使用。例如：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;tb_login_log&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginLog</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="meta">@OneToOne</span></span><br><span class="line">    <span class="meta">@JoinColumn(name = &quot;user_id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//... get、set</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>@OneToOne、@OneToMany 和@ManyToOne</strong>：这三个注解相当于 hibernate 配置文件中的一对一、一对多和多对一配置。例如，在以下客户地址表中，可以通过客户 ID 查询客户信息。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;address&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AddressEO</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line">    <span class="meta">@ManyToOne(cascade = &#123;CascadeType.ALL&#125;)</span></span><br><span class="line">    <span class="meta">@JoinColumn(name = &quot;customer_id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> CustomerEO customer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//... get、set</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-异常处理相关注解"><a href="#7-异常处理相关注解" class="headerlink" title="7. 异常处理相关注解"></a><strong>7. 异常处理相关注解</strong></h2><ul>
<li><strong>@ControllerAdvice 和@ExceptionHandler</strong>：它们通常一起使用来处理全局异常。示例代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionConfig</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">GLOBAL_ERROR_CODE</span> <span class="operator">=</span> <span class="number">500</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(value = Exception.class)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionHandler</span><span class="params">(HttpServletRequest request, HttpServletResponse</span></span><br><span class="line"><span class="params">            response, Exception e)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        log.error(<span class="string">&quot;统一异常处理器：&quot;</span>, e);</span><br><span class="line">        ResultMsg&lt;Object&gt; resultMsg = <span class="keyword">new</span> <span class="title class_">ResultMsg</span>&lt;&gt;();</span><br><span class="line">        resultMsg.setCode(GLOBAL_ERROR_CODE);</span><br><span class="line">        <span class="keyword">if</span> (e <span class="keyword">instanceof</span> CommonException) &#123;</span><br><span class="line">            <span class="type">CommonException</span> <span class="variable">ex</span> <span class="operator">=</span> (CommonException) e;</span><br><span class="line">            <span class="keyword">if</span> (ex.getErrCode()!= <span class="number">0</span>) &#123;</span><br><span class="line">                resultMsg.setCode(ex.getErrCode());</span><br><span class="line">            &#125;</span><br><span class="line">            resultMsg.setMsg(ex.getErrMsg());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            resultMsg.setMsg(CommonErrorMsg.SYSTEM_ERROR.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        WebUtil.buildPrintWriter(response, resultMsg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-AOP-相关注解"><a href="#8-AOP-相关注解" class="headerlink" title="8. AOP 相关注解"></a><strong>8. AOP 相关注解</strong></h2><ul>
<li><strong>@Aspect</strong>：用于定义一个切面。切面是通知和切入点的组合，它定义了在何时何地应用通知功能。</li>
<li><strong>@Before</strong>：表示前置通知。通知方法将在目标方法调用之前执行。通知描述了切面要执行的工作以及执行的时间。</li>
<li><strong>@After</strong>：表示后置通知。通知方法将在目标方法返回或抛出异常后执行。</li>
<li><strong>@AfterReturning</strong>：表示返回通知。通知方法将在目标方法返回后执行。</li>
<li><strong>@AfterThrowing</strong>：表示异常通知。通知方法将在目标方法抛出异常后执行。</li>
<li><strong>@Around</strong>：表示环绕通知。通知方法将包装目标方法，并在目标方法调用前后执行自定义行为。</li>
<li><strong>@Pointcut</strong>：定义切入点表达式，它定义了应用通知功能的范围。</li>
<li><strong>@Order</strong>：用于定义组件的执行顺序。在 AOP 中，它指的是切面的执行顺序。value 属性的值越小，表示优先级越高。 示例：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 统一日志处理切面</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Order(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebLogAspect</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">LOGGER</span> <span class="operator">=</span> LoggerFactory.getLogger(WebLogAspect.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(public * com.dylan.smith.web.controller.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">webLog</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;webLog()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doBefore</span><span class="params">(JoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning(value = &quot;webLog()&quot;, returning = &quot;ret&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAfterReturning</span><span class="params">(Object ret)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;webLog()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">doAround</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">WebLog</span> <span class="variable">webLog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WebLog</span>();</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> joinPoint.proceed();</span><br><span class="line">        LOGGER.info(<span class="string">&quot;&#123;&#125;&quot;</span>, JSONUtil.parse(webLog));</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-测试相关注解"><a href="#9-测试相关注解" class="headerlink" title="9. 测试相关注解"></a><strong>9. 测试相关注解</strong></h2><ul>
<li><strong>@Test</strong>：指定一个方法为测试方法。</li>
<li><strong>@ActiveProfiles</strong>：一般应用于测试类，用于声明活动的 Spring 配置文件。例如，指定 application - dev.properties 配置文件。</li>
<li><strong>@RunWith 和@SpringBootTest</strong>：一般应用于测试类，用于单元测试。示例如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ActiveProfiles(&quot;dev&quot;)</span></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestJunit</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">executeTask</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2025/01/09/nginx/" rel="prev" title="nginx">
      <i class="fa fa-chevron-left"></i> nginx
    </a></div>
      <div class="post-nav-item">
    <a href="/2025/01/11/redis/" rel="next" title="redis快速入门">
      redis快速入门 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#configuration"><span class="nav-number">1.</span> <span class="nav-text">@configuration</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%BB%E8%A6%81%E4%BD%9C%E7%94%A8%EF%BC%9A"><span class="nav-number">1.1.</span> <span class="nav-text">主要作用：</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RequestBody"><span class="nav-number">2.</span> <span class="nav-text">@RequestBody</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%94%A8%E6%B3%95%EF%BC%9A"><span class="nav-number">2.1.</span> <span class="nav-text">用法：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A"><span class="nav-number">2.2.</span> <span class="nav-text">示例：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A7%A3%E9%87%8A%EF%BC%9A"><span class="nav-number">2.3.</span> <span class="nav-text">解释：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%94%A8%E9%80%94%EF%BC%9A"><span class="nav-number">2.4.</span> <span class="nav-text">常见用途：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E4%BA%8B%E9%A1%B9%EF%BC%9A"><span class="nav-number">2.5.</span> <span class="nav-text">需要注意的事项：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Autowired"><span class="nav-number"></span> <span class="nav-text">@Autowired</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8%E6%B3%95%E5%92%8C%E4%BD%9C%E7%94%A8%EF%BC%9A"><span class="nav-number">1.</span> <span class="nav-text">用法和作用：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BB%E8%A6%81%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="nav-number">2.</span> <span class="nav-text">主要的使用方式：</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E5%AD%97%E6%AE%B5%E6%B3%A8%E5%85%A5"><span class="nav-number">2.1.</span> <span class="nav-text">1. 字段注入</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E6%B3%A8%E5%85%A5"><span class="nav-number">2.2.</span> <span class="nav-text">2. 构造方法注入</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-Setter-%E6%96%B9%E6%B3%95%E6%B3%A8%E5%85%A5"><span class="nav-number">2.3.</span> <span class="nav-text">3. Setter 方法注入</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E6%B3%A8%E5%85%A5%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%9A"><span class="nav-number">3.</span> <span class="nav-text">自动注入的原理：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BE%8B%E5%A4%96%E5%92%8C%E9%85%8D%E7%BD%AE%EF%BC%9A"><span class="nav-number">4.</span> <span class="nav-text">例外和配置：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="nav-number">5.</span> <span class="nav-text">总结：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E7%BB%84%E4%BB%B6%E7%9B%B8%E5%85%B3%E6%B3%A8%E8%A7%A3"><span class="nav-number"></span> <span class="nav-text">1. 组件相关注解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E4%B8%8E-Bean-%E5%AE%9E%E4%BE%8B%E5%92%8C%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9B%B8%E5%85%B3%E7%9A%84%E6%B3%A8%E8%A7%A3"><span class="nav-number"></span> <span class="nav-text">2. 与 Bean 实例和生命周期相关的注解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%B3%A8%E8%A7%A3"><span class="nav-number"></span> <span class="nav-text">3. 依赖注入注解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-SpringMVC-%E7%9B%B8%E5%85%B3%E6%B3%A8%E8%A7%A3"><span class="nav-number"></span> <span class="nav-text">4. SpringMVC 相关注解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E9%85%8D%E7%BD%AE%E7%9B%B8%E5%85%B3%E6%B3%A8%E8%A7%A3"><span class="nav-number"></span> <span class="nav-text">5. 配置相关注解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-JPA-%E7%9B%B8%E5%85%B3%E6%B3%A8%E8%A7%A3"><span class="nav-number"></span> <span class="nav-text">6. JPA 相关注解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E6%B3%A8%E8%A7%A3"><span class="nav-number"></span> <span class="nav-text">7. 异常处理相关注解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-AOP-%E7%9B%B8%E5%85%B3%E6%B3%A8%E8%A7%A3"><span class="nav-number"></span> <span class="nav-text">8. AOP 相关注解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-%E6%B5%8B%E8%AF%95%E7%9B%B8%E5%85%B3%E6%B3%A8%E8%A7%A3"><span class="nav-number"></span> <span class="nav-text">9. 测试相关注解</span></a></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">20</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
